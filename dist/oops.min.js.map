{"version":3,"file":"oops.min.js","mappings":"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","sources":["webpack://Oops/webpack/universalModuleDefinition","webpack://Oops/./src/Oops.js","webpack://Oops/./src/index.js","webpack://Oops/webpack/bootstrap","webpack://Oops/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Oops\"] = factory();\n\telse\n\t\troot[\"Oops\"] = factory();\n})(this, () => {\nreturn ","class Oops {\n    constructor(options = {}) {\n        this.undoStack = [];\n        this.redoStack = [];\n        this.maxStackSize = options.maxStackSize || Infinity;\n        this.isExecuting = false;\n        this.changeListeners = new Set();\n        this.commandFactories = new Map();\n        this.transactionStack = [];\n        this.snapshots = new Map();\n        this.snapshotInterval = options.snapshotInterval || 10;\n        this.compressThreshold = options.compressThreshold || 100;\n        this.lastExecutionTime = 0;\n        this.mergeWindow = options.mergeWindow || 1000; // in milliseconds\n    }\n\n    /**\n     * Executes a command and optionally adds it to the undo stack.\n     * \n     * @param {Command|string} command - The command to execute. Can be a Command object or a string identifier for a registered command.\n     * @param {Object} [options={}] - Execution options.\n     * @param {boolean} [options.silent=false] - If true, suppresses notification to listeners after execution.\n     * @param {boolean} [options.undoable=true] - If false, the command will not be added to the undo stack.\n     * @returns {*} The result of the command execution, if any.\n     * @throws {Error} If an unknown command string is provided or if command execution fails.\n     * \n     * @description\n     * This method performs the following steps:\n     * 1. Checks if a command is already being executed to prevent recursion.\n     * 2. If the command is a string, it looks up and instantiates the corresponding Command object.\n     * 3. Executes the command and captures its result.\n     * 4. If undoable, attempts to merge the command with the previous one if conditions are met.\n     * 5. If undoable, adds the command to the undo stack and clears the redo stack.\n     * 6. If undoable, manages the undo stack size, creates snapshots, and compresses history if necessary.\n     * 7. Notifies listeners of the state change unless silent mode is enabled.\n     * \n     * @example\n     * // Execute a command object (undoable by default)\n     * undoRedoManager.execute(new SomeCommand());\n     * \n     * // Execute a registered command by name (undoable by default)\n     * undoRedoManager.execute('someRegisteredCommand');\n     * \n     * // Execute silently (without notifying listeners)\n     * undoRedoManager.execute(someCommand, { silent: true });\n     * \n     * // Execute non-undoable command\n     * undoRedoManager.execute(someCommand, { undoable: false });\n     */\n    execute(command, options = {}) {\n        const { silent = false, undoable = true } = options;\n\n        if (this.isExecuting) return;\n        this.isExecuting = true;\n\n        try {\n            if (typeof command === 'string') {\n                const factory = this.commandFactories.get(command);\n                if (!factory) throw new Error(`Unknown command: ${command}`);\n                command = factory();\n            }\n\n            // Check if there's an active transaction\n            if (this.transactionStack.length > 0) {\n                // If there is, add the command to the current transaction\n                this.transactionStack[this.transactionStack.length - 1].push(command);\n                return; // Don't execute the command yet\n            }\n\n            const result = command.execute();\n\n            if (undoable) {\n                const currentTime = Date.now();\n                if (this.undoStack.length > 0 && \n                    currentTime - this.lastExecutionTime < this.mergeWindow &&\n                    command.canMerge && \n                    command.canMerge(this.undoStack[this.undoStack.length - 1])) {\n                    const mergedCommand = command.merge(this.undoStack.pop());\n                    this.undoStack.push(mergedCommand);\n                } else {\n                    this.undoStack.push(command);\n                }\n\n                this.lastExecutionTime = currentTime;\n                this.redoStack = [];\n\n                if (this.undoStack.length > this.maxStackSize) {\n                    this.undoStack.shift();\n                }\n\n                if (this.undoStack.length % this.snapshotInterval === 0) {\n                    this.createSnapshot();\n                }\n\n                if (this.undoStack.length > this.compressThreshold) {\n                    this.compressHistory();\n                }\n            }\n\n            if (!silent) this.notifyListeners();\n\n            return result;\n        } catch (error) {\n            console.error(\"Error executing command:\", error);\n            throw error;\n        } finally {\n            this.isExecuting = false;\n        }\n    }\n\n    /**\n     * Undoes a specified number of commands from the undo stack.\n     * \n     * @param {number} [steps=1] - The number of commands to undo. Defaults to 1 if not specified.\n     * @throws {Error} If an error occurs during the undo operation.\n     * \n     * @description\n     * This method performs the following steps:\n     * 1. Checks if undo operation is possible (not currently executing and undo stack is not empty).\n     * 2. Undoes the specified number of commands or as many as possible if fewer are available.\n     * 3. Moves undone commands to the redo stack.\n     * 4. Notifies listeners of the state change.\n     * 5. If an error occurs, attempts to recover from the last valid snapshot.\n     * \n     * @example\n     * // Undo the last command\n     * undoRedoManager.undo();\n     * \n     * // Undo the last 3 commands\n     * undoRedoManager.undo(3);\n     */\n    undo(steps = 1) {\n        if (this.isExecuting || this.undoStack.length === 0) return;\n        this.isExecuting = true;\n\n        try {\n            const undoneCommands = [];\n            for (let i = 0; i < steps && this.undoStack.length > 0; i++) {\n                const command = this.undoStack.pop();\n                command.undo();\n                undoneCommands.unshift(command);\n            }\n            this.redoStack.push(...undoneCommands);\n            this.notifyListeners();\n        } catch (error) {\n            console.error(\"Error undoing command:\", error);\n            this.recoverFromSnapshot();\n        } finally {\n            this.isExecuting = false;\n        }\n    }\n\n    /**\n     * Redoes a specified number of commands from the redo stack.\n     * \n     * @param {number} [steps=1] - The number of commands to redo. Defaults to 1 if not specified.\n     * @throws {Error} If an error occurs during the redo operation.\n     * \n     * @description\n     * This method performs the following steps:\n     * 1. Checks if redo operation is possible (not currently executing and redo stack is not empty).\n     * 2. Redoes the specified number of commands or as many as possible if fewer are available.\n     * 3. Moves redone commands back to the undo stack.\n     * 4. Notifies listeners of the state change.\n     * 5. If an error occurs, attempts to recover from the last valid snapshot.\n     * \n     * @example\n     * // Redo the last undone command\n     * undoRedoManager.redo();\n     * \n     * // Redo the last 3 undone commands\n     * undoRedoManager.redo(3);\n     */\n    redo(steps = 1) {\n        if (this.isExecuting || this.redoStack.length === 0) return;\n        this.isExecuting = true;\n\n        try {\n            const redoneCommands = [];\n            for (let i = 0; i < steps && this.redoStack.length > 0; i++) {\n                const command = this.redoStack.pop();\n                command.execute();\n                redoneCommands.unshift(command);\n            }\n            this.undoStack.push(...redoneCommands);\n            this.notifyListeners();\n        } catch (error) {\n            console.error(\"Error redoing command:\", error);\n            this.recoverFromSnapshot();\n        } finally {\n            this.isExecuting = false;\n        }\n    }\n\n    /**\n     * Begins a new transaction.\n     * \n     * @description\n     * This method starts a new transaction by creating an empty array and pushing it onto the transaction stack.\n     * Transactions allow grouping multiple commands together to be executed as a single unit.\n     * \n     * @example\n     * undoRedoManager.beginTransaction();\n     * // Execute multiple commands...\n     * undoRedoManager.commitTransaction();\n     */\n    beginTransaction() {\n        this.transactionStack.push([]);\n    }\n\n    /**\n     * Commits the current transaction.\n     * \n     * @description\n     * This method finalizes the current transaction by popping it off the transaction stack and executing it.\n     * If the transaction contains only one command, it's executed directly.\n     * If it contains multiple commands, they're wrapped in a CompositeCommand before execution.\n     * If the transaction stack is empty, this method does nothing.\n     * \n     * @throws {Error} If an error occurs during the execution of the transaction commands.\n     * \n     * @example\n     * undoRedoManager.beginTransaction();\n     * undoRedoManager.execute(command1);\n     * undoRedoManager.execute(command2);\n     * undoRedoManager.commitTransaction();\n     */\n    commitTransaction() {\n        if (this.transactionStack.length === 0) return;\n        const transaction = this.transactionStack.pop();\n        if (transaction.length === 1) {\n            this.execute(transaction[0]);\n        } else if (transaction.length > 1) {\n            const compositeCommand = new CompositeCommand(transaction);\n            this.execute(compositeCommand);\n        }\n    }\n\n    /**\n     * Aborts the current transaction.\n     * \n     * @description\n     * This method cancels the current transaction by popping it off the transaction stack and undoing all commands\n     * in reverse order. If the transaction stack is empty, this method does nothing.\n     * \n     * @throws {Error} If an error occurs while undoing the transaction commands.\n     * \n     * @example\n     * undoRedoManager.beginTransaction();\n     * undoRedoManager.execute(command1);\n     * undoRedoManager.execute(command2);\n     * undoRedoManager.abortTransaction(); // Undoes command2 and command1\n     */\n    abortTransaction() {\n        if (this.transactionStack.length === 0) return;\n        const transaction = this.transactionStack.pop();\n        for (let i = transaction.length - 1; i >= 0; i--) {\n            transaction[i].undo();\n        }\n    }\n\n    /**\n     * Registers a command factory with a given name.\n     * \n     * @param {string} name - The name to associate with the command factory.\n     * @param {Function} factory - A function that returns a new instance of the command.\n     * \n     * @description\n     * This method allows registering command factories by name, enabling the creation of commands\n     * using string identifiers. Registered commands can be executed by passing their name to the execute method.\n     * \n     * @example\n     * undoRedoManager.registerCommand('createUser', () => new CreateUserCommand());\n     * undoRedoManager.execute('createUser'); // Creates and executes a new CreateUserCommand\n     */\n    registerCommand(name, factory) {\n        this.commandFactories.set(name, factory);\n    }\n\n    /**\n     * Creates a snapshot of the current undo and redo stacks.\n     * \n     * @description\n     * This method creates a serialized snapshot of the current state of the undo and redo stacks.\n     * The snapshot is stored in the snapshots Map, indexed by the current size of the undo stack.\n     * Snapshots are used for recovery in case of errors during undo or redo operations.\n     * \n     * @example\n     * undoRedoManager.createSnapshot();\n     */\n    createSnapshot() {\n        const snapshot = {\n            undoStack: this.undoStack.map(cmd => cmd.serialize()),\n            redoStack: this.redoStack.map(cmd => cmd.serialize())\n        };\n        this.snapshots.set(this.undoStack.length, snapshot);\n    }\n\n    /**\n     * Recovers the state from the most recent valid snapshot.\n     * \n     * @description\n     * This method attempts to recover the undo and redo stacks from the most recent snapshot\n     * that is not larger than the current undo stack size. It's typically called after an error\n     * occurs during an undo or redo operation to restore the system to a consistent state.\n     * After recovery, it notifies all listeners of the state change.\n     * \n     * @throws {Error} If deserialization of commands fails.\n     * \n     * @example\n     * try {\n     *     // Some undo/redo operation\n     * } catch (error) {\n     *     undoRedoManager.recoverFromSnapshot();\n     * }\n     */\n    recoverFromSnapshot() {\n        const snapshotKeys = Array.from(this.snapshots.keys()).sort((a, b) => b - a);\n        for (const key of snapshotKeys) {\n            if (key <= this.undoStack.length) {\n                const snapshot = this.snapshots.get(key);\n                this.undoStack = snapshot.undoStack.map(cmd => this.deserializeCommand(cmd));\n                this.redoStack = snapshot.redoStack.map(cmd => this.deserializeCommand(cmd));\n                break;\n            }\n        }\n        this.notifyListeners();\n    }\n\n    /**\n     * Deserializes a command from its serialized form.\n     * \n     * @param {Object} serializedCmd - The serialized command object.\n     * @returns {Command} The deserialized command object.\n     * \n     * @description\n     * This method takes a serialized command object and uses the registered command factories\n     * to create a new instance of the command. It's used when recovering from snapshots.\n     * \n     * @throws {Error} If the command type is unknown or not registered.\n     * \n     * @example\n     * const deserializedCmd = undoRedoManager.deserializeCommand({type: 'SomeCommand', data: {...}});\n     */\n    deserializeCommand(serializedCmd) {\n        const factory = this.commandFactories.get(serializedCmd.type);\n        if (!factory) throw new Error(`Unknown command type: ${serializedCmd.type}`);\n        return factory(serializedCmd.data);\n    }\n\n    /**\n     * Compresses the undo history by merging compatible commands.\n     * \n     * @description\n     * This method goes through the undo stack and attempts to merge adjacent commands\n     * that are compatible (as determined by their canMerge method). This can help reduce\n     * memory usage and simplify the undo/redo history.\n     * \n     * @example\n     * undoRedoManager.compressHistory();\n     */\n    compressHistory() {\n        const compressedStack = [];\n        let currentGroup = null;\n\n        for (const command of this.undoStack) {\n            if (currentGroup && currentGroup.canMerge(command)) {\n                currentGroup = currentGroup.merge(command);\n            } else {\n                if (currentGroup) compressedStack.push(currentGroup);\n                currentGroup = command;\n            }\n        }\n\n        if (currentGroup) compressedStack.push(currentGroup);\n        this.undoStack = compressedStack;\n    }\n\n    /**\n     * Adds a change listener to be notified of state changes.\n     * \n     * @param {Function} listener - The listener function to be called on state changes.\n     * \n     * @description\n     * This method adds a listener function to be notified whenever the undo/redo state changes.\n     * The listener will receive an object with the current state information.\n     * \n     * @example\n     * undoRedoManager.addChangeListener((state) => {\n     *     console.log('Undo/Redo state changed:', state);\n     * });\n     */\n    addChangeListener(listener) {\n        this.changeListeners.add(listener);\n    }\n\n    /**\n     * Removes a previously added change listener.\n     * \n     * @param {Function} listener - The listener function to be removed.\n     * \n     * @description\n     * This method removes a previously added listener function from the set of change listeners.\n     * The listener will no longer be notified of state changes.\n     * \n     * @example\n     * const listener = (state) => console.log('State changed:', state);\n     * undoRedoManager.addChangeListener(listener);\n     * // ... later ...\n     * undoRedoManager.removeChangeListener(listener);\n     */\n    removeChangeListener(listener) {\n        this.changeListeners.delete(listener);\n    }\n\n    /**\n     * Notifies all registered listeners of the current state.\n     * \n     * @description\n     * This method creates a state object with the current undo/redo information\n     * and calls all registered listener functions with this state. It's typically\n     * called after operations that might change the undo/redo state.\n     * \n     * @example\n     * // This is usually called internally, but could be used like this:\n     * undoRedoManager.execute(someCommand);\n     * undoRedoManager.notifyListeners();\n     */\n    notifyListeners() {\n        const state = {\n            canUndo: this.canUndo,\n            canRedo: this.canRedo,\n            undoStackSize: this.undoStack.length,\n            redoStackSize: this.redoStack.length\n        };\n        for (const listener of this.changeListeners) {\n            listener(state);\n        }\n    }\n\n    /**\n     * Clears all undo and redo history.\n     * \n     * @description\n     * This method resets the undo and redo stacks to empty arrays, clears all snapshots,\n     * and notifies listeners of the state change. It effectively resets the entire\n     * undo/redo system to its initial state.\n     * \n     * @example\n     * undoRedoManager.clear();\n     * console.log(undoRedoManager.canUndo); // false\n     * console.log(undoRedoManager.canRedo); // false\n     */\n    clear() {\n        this.undoStack = [];\n        this.redoStack = [];\n        this.snapshots.clear();\n        this.notifyListeners();\n    }\n\n    /**\n     * Checks if there are any actions that can be undone.\n     * \n     * @returns {boolean} True if there are actions in the undo stack, false otherwise.\n     * \n     * @description\n     * This getter provides a quick way to check if there are any actions\n     * in the undo stack that can be reversed.\n     * \n     * @example\n     * if (undoRedoManager.canUndo) {\n     *     undoButton.enable();\n     * } else {\n     *     undoButton.disable();\n     * }\n     */\n    get canUndo() {\n        return this.undoStack?.length > 0;\n    }\n\n    /**\n     * Checks if there are any actions that can be redone.\n     * \n     * @returns {boolean} True if there are actions in the redo stack, false otherwise.\n     * \n     * @description\n     * This getter provides a quick way to check if there are any undone actions\n     * in the redo stack that can be reapplied.\n     * \n     * @example\n     * if (undoRedoManager.canRedo) {\n     *     redoButton.enable();\n     * } else {\n     *     redoButton.disable();\n     * }\n     */\n    get canRedo() {\n        return this.redoStack?.length > 0;\n    }\n    \n    /**\n     * Exports the current state of the undo/redo manager.\n     * \n     * @returns {Object} An object representing the serialized state.\n     * \n     * @description\n     * This method creates a serializable object containing the current state\n     * of the undo and redo stacks, as well as any relevant configuration.\n     * The returned object can be easily converted to JSON for storage.\n     * \n     * @example\n     * const state = undoRedoManager.exportState();\n     * const jsonState = JSON.stringify(state);\n     * // Developer can now save jsonState to file, localStorage, etc.\n     */\n    exportState() {\n        return {\n            undoStack: this.undoStack.map(cmd => cmd.serialize()),\n            redoStack: this.redoStack.map(cmd => cmd.serialize()),\n            maxStackSize: this.maxStackSize,\n            snapshotInterval: this.snapshotInterval,\n            compressThreshold: this.compressThreshold,\n            mergeWindow: this.mergeWindow\n        };\n    }\n\n    /**\n     * Imports a previously exported state into the undo/redo manager.\n     * \n     * @param {Object} state - The state object to import.\n     * @throws {Error} If the state object is invalid or commands can't be deserialized.\n     * \n     * @description\n     * This method takes a state object (typically created by exportState)\n     * and restores the undo/redo manager to that state. It deserializes\n     * the undo and redo stacks and restores configuration settings.\n     * \n     * @example\n     * // Assuming jsonState is retrieved from storage\n     * const state = JSON.parse(jsonState);\n     * undoRedoManager.importState(state);\n     */\n    importState(state) {\n        if (!state || typeof state !== 'object') {\n            throw new Error('Invalid state object');\n        }\n\n        try {\n            this.undoStack = state.undoStack.map(cmd => this.deserializeCommand(cmd));\n            this.redoStack = state.redoStack.map(cmd => this.deserializeCommand(cmd));\n            this.maxStackSize = state.maxStackSize || this.maxStackSize;\n            this.snapshotInterval = state.snapshotInterval || this.snapshotInterval;\n            this.compressThreshold = state.compressThreshold || this.compressThreshold;\n            this.mergeWindow = state.mergeWindow || this.mergeWindow;\n\n            // Reset other internal state\n            this.isExecuting = false;\n            this.lastExecutionTime = 0;\n            this.transactionStack = [];\n            this.snapshots.clear();\n\n            this.notifyListeners();\n        } catch (error) {\n            throw new Error('Failed to import state: ' + error.message);\n        }\n    }\n\n    /**\n     * Serializes the current state to a JSON string.\n     * \n     * @returns {string} A JSON string representing the current state.\n     * \n     * @description\n     * This is a convenience method that exports the state and converts it to a JSON string.\n     * \n     * @example\n     * const jsonState = undoRedoManager.serializeState();\n     * // Developer can now save jsonState to file, localStorage, etc.\n     */\n    serializeState() {\n        return JSON.stringify(this.exportState());\n    }\n\n    /**\n     * Deserializes a JSON string and imports the state.\n     * \n     * @param {string} jsonState - A JSON string representing a previously serialized state.\n     * @throws {Error} If the JSON is invalid or state import fails.\n     * \n     * @description\n     * This is a convenience method that parses a JSON string and imports the resulting state.\n     * \n     * @example\n     * // Assuming jsonState is retrieved from storage\n     * undoRedoManager.deserializeState(jsonState);\n     */\n    deserializeState(jsonState) {\n        try {\n            const state = JSON.parse(jsonState);\n            this.importState(state);\n        } catch (error) {\n            throw new Error('Failed to deserialize state: ' + error.message);\n        }\n    }\n}\n\nclass CompositeCommand {\n    constructor(commands) {\n        this.commands = commands;\n    }\n\n    execute() {\n        for (const command of this.commands) {\n            command.execute();\n        }\n    }\n\n    undo() {\n        for (let i = this.commands.length - 1; i >= 0; i--) {\n            this.commands[i].undo();\n        }\n    }\n\n    serialize() {\n        return {\n            type: 'CompositeCommand',\n            data: this.commands.map(cmd => cmd.serialize())\n        };\n    }\n\n    static deserialize(data, deserializeCommand) {\n        return new CompositeCommand(data.map(deserializeCommand));\n    }\n\n    canMerge(other) {\n        return false; // CompositeCommands typically can't be merged\n    }\n}\n\n// export default Oops;\nmodule.exports = Oops;","const Oops = require('./Oops.js');\nmodule.exports = Oops;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(44);\n"],"names":["root","factory","exports","module","define","amd","this","CompositeCommand","constructor","commands","execute","command","undo","i","length","serialize","type","data","map","cmd","deserialize","deserializeCommand","canMerge","other","options","undoStack","redoStack","maxStackSize","Infinity","isExecuting","changeListeners","Set","commandFactories","Map","transactionStack","snapshots","snapshotInterval","compressThreshold","lastExecutionTime","mergeWindow","silent","undoable","get","Error","push","result","currentTime","Date","now","mergedCommand","merge","pop","shift","createSnapshot","compressHistory","notifyListeners","error","console","steps","undoneCommands","unshift","recoverFromSnapshot","redo","redoneCommands","beginTransaction","commitTransaction","transaction","compositeCommand","abortTransaction","registerCommand","name","set","snapshot","snapshotKeys","Array","from","keys","sort","a","b","key","serializedCmd","compressedStack","currentGroup","addChangeListener","listener","add","removeChangeListener","delete","state","canUndo","canRedo","undoStackSize","redoStackSize","clear","exportState","importState","message","serializeState","JSON","stringify","deserializeState","jsonState","parse","Oops","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}